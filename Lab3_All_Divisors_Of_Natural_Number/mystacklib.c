//	Программа All_Divisors_Of_Natural_Number
//
//	Текущий файл mystacklib.с содержит тела связанных со стеками функций, необходимых для решения данной задачи.
//
//	Автор: Степаненко Кирилл
//	Группа: ИВТ-13БО
//
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "mystacklib.h"

stackElement * createElement(int inData) {
	struct stackElement* element;							//Указатель на новый создаваемый элемент списка.
	if (!(element = (stackElement*)malloc(sizeof(stackElement)))) {
		printf("Ошибка выделения памяти. Закройте ненужные приложения и повторите попытку.");
		exit(0);
	}
	element->value = inData;
	element->next = NULL;
	return element;
}

stackElement * findAndPrintDivisors(int number) {
	int divisor;						//Текущее число, проверяемое на делитель.
	double numberSqrt = sqrt(number);
	stackElement * curElement = NULL;	//Указатель на текущий элемент.
	printf("Делители числа %d:", number);
	for (divisor = 1; divisor <= numberSqrt; divisor++) {	//Проверяем, является ли число делителем.
		if (number % divisor == 0) {
			push(&curElement, divisor);
			printf(" %d", divisor);
		}
	}
	for ( ; !isEmpty(curElement); ) {
		if (getValue(curElement) != numberSqrt) {
			printf(" %d", number/pop(&curElement));
		}
		else
			pop(&curElement);
	}
	printf(".");
	return curElement;
}

int freeStack(stackElement * element) {
	for ( ; !isEmpty(element); )
		pop(&element);
	return 0;
}

int getNumber() {
	int number;
	printf("Введите натуральное число n, для которого требуется найти все делители: ");
	if (!scanf("%d", &number)) {
		printf("Введённая строка не является натуральным числом, повторите попытку.");
		exit(0);
	}
	if (number <= 0) {
		printf("Введённое число или не является натуральным, или больше %d, повторите попытку.", INT_MAX);
		exit(0);
	}
	return number;
}

int getValue(stackElement * element) {
	if (isEmpty(element))	//Если элемента не существует, то возвращаем 0, потому что 0 - удобно, и он не может быть делителем.
		return 0;
	return element->value;
}

int isEmpty(stackElement * element) {
	return !element;
}

void push(stackElement ** prevElement, int value) {
	stackElement* element;			//Указатель на новый создаваемый элемент списка
	element = createElement(value);
	element->next = *prevElement;
	*prevElement = element;
}

int pop(stackElement ** element) {
	if (isEmpty(*element))	//Если элемента не существует, то возвращаем 0, потому что 0 - удобно, и он не может быть делителем.
		return 0;
	int tempValue;					//Указатель на временно хранящееся значение для его возврата.
	stackElement* temp;				//Указатель на элемент, который нужно удалить.
	temp = *element;
	*element = (*element)->next;
	tempValue = getValue(temp);
	free(temp);
	return tempValue;
}
