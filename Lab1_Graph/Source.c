/*
*	Программа Граф_Конь (Graph_Horse)
*
*	Программа предназначена для выполнения задания при следующих условиях:
*
*	Имеется поле необычной формы, заданного размера. Каждая клетка пронумерована числами от 1 и далее начиная с верхнего ряда слева направо.
*	Количество горизонтальных рядов в поле, а также количество клеток в рядах поля задаётся пользователем.
*	Фигура - конь. Ходы идентичны таковым у шахматного (Г-образные).
*	Поле представляет собой видоизменённый прямоугольник, каждый следующий ряд которого смещён на *номер ряда* клеток вправо,
*	относительно первого ряда (нулевого), при условии нумерации рядов начиная с 0, или же просто на 1 клетку вправо относительно предыдущего ряда.
*
*	Задание:
*
*	Найти путь фигуры из заданного начального положения в заданное конечное положение (положения задаются номерами строк и позиций в строке)
*	и вывести на экран последовательность чисел, стоящих в клетках этого пути при условии, что нельзя вставать фигурой на две заданные запрещённые клетки.
*
*	Текущий файл Source.c содержит в себе основную функцию main и включение всех необходимых файлов.
*
*	Автор: Степаненко Кирилл
*	Группа: ИВТ-13БО
*/
#define _CRT_SECURE_NO_WARNINGS
#include <locale.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "mygraphlib.h"

void main() {
	int ranksAmount,		//Количество рядов в поле.
		filesAmount,		//Количество клеток в ряду.
		initRank,			//Номер ряда в начальном положении.
		initFile,			//Номер клетки в начальном положении.
		targetRank,			//Номер ряда в конечном положении.
		targetFile,			//Номер клетки в конечном положении.
		prohRank1,			//Номер ряда первой запрещённой клетки.
		prohFile1,			//Номер первой запрещённой клетки в указанном ряду.
		prohRank2,			//Номер ряда второй запрещённой клетки.
		prohFile2,			//Номер второй запрещённой клетки в указанном ряду.
		*** field = NULL,	//Указатель на поле. В ячейке field[i][j][0] хранится значение ячейки. В field[i][j][1] - пометка о том, посещали ли её, является ли она целевой и т.д.
		i,					//Счётчик.
		j,					//Счётчик.
		fillerCnt = 1;		//Счётчик для заполнения поля числами от 1 и далее.
	struct list* pQueue = NULL,	//Указатель на начало очереди для горизонтального обхода графа. В дальнейшем - элемент очереди.
		* pQueueLast = NULL,		//Указатель на последний элемент очереди.
		* pTemp;					//Временный указатель на предыдущий элемент очереди для определения, сдвинулась ли очередь вперёд.
	setlocale(LC_ALL, "RUS");
	greetUser();
	//Ввод количества рядов и клеток
	inputRanksAndFiles(&ranksAmount, &filesAmount);
	//Выделение памяти для поля и заполнение его числами.
	createAndFillField(&field, ranksAmount, filesAmount);
	//Ввод начальных координат
	inputInitPos(&initRank, &initFile, ranksAmount, filesAmount);
	//Ввод конечных координат
	inputTargetPos(&targetRank, &targetFile, ranksAmount, filesAmount);
	//Ввод координат первой запрещённой клетки.
	inputProhPos(&prohRank1, &prohFile1, ranksAmount, filesAmount);
	//Ввод координат второй запрещённой клетки.
	inputProhPos(&prohRank2, &prohFile2, ranksAmount, filesAmount);
	//Проверка на совпадение координат запрещённых клеток с начальными и предупреждение об этом пользователя.
	notifyAboutSameCoords(initRank, initFile, targetRank, targetFile, prohRank1, prohFile1, prohRank2, prohFile2);

	//Пометка указанных запрещённых клеток как посещённых.
	field[prohRank1][prohFile1][1] = VISITED;
	field[prohRank2][prohFile2][1] = VISITED;
	field[targetRank][targetFile][1] = TARGET;		//Пометка целевой клетки как целевой
	field[initRank][initFile][1] = VISITED;
	//Выделение памяти для первого элемента очереди.
	pQueue = createFirstElem(field, initRank, initFile);
	pQueueLast = pQueue;
	//Блок вызова функции, добавляющей в очередь возможные ходы.
	while (1) {
		if (getPosSteps(pQueue, &pQueueLast, field, ranksAmount, filesAmount))
			break;
		if (!(pQueue->pNext)) {
			printf("Не удалось найти путь с указанными параметрами.");
			break;
		}
		pQueue = pQueue->pNext;
	}
	//Блок очистки памяти.
	clearQueue(pQueue);
	field = freeMyField(field, ranksAmount, filesAmount);
	//printf("Brk"); 
}

int createAndFillField(int **** field, int ranksAmount, int filesAmount) {
	int fillerCnt = 1;	//Счётчик для заполнения поля числами от 1 и далее.
	if (!(*field = malloc(ranksAmount * sizeof(int**)))) {	//Проверяем на NULL при выделении памяти
		printf("Ошибка выделения памяти для массива. Поробуйте закрыть ненужные приложения и повторить попытку.");
		exit(0);
	}
	for (int i = 0; i < ranksAmount; i++) {
		(*field)[i] = NULL;
		if (!((*field)[i] = malloc(filesAmount * sizeof(int*)))) {	//Проверяем на NULL при выделении памяти
			printf("Ошибка выделения памяти для массива. Поробуйте закрыть ненужные приложения и повторить попытку.");
			exit(0);
		}
	}
	for (int i = 0; i < ranksAmount; i++) {
		for (int j = 0; j < filesAmount; j++) {
			if (!((*field)[i][j] = malloc(2 * sizeof(int)))) {	//Проверяем на NULL при выделении памяти
				printf("Ошибка выделения памяти для массива. Поробуйте закрыть ненужные приложения и повторить попытку.");
				exit(0);
			}
			(*field)[i][j][0] = fillerCnt++;
			//printf(" %d", field[i][j][0]);
			(*field)[i][j][1] = NOTVISITED;
		}
	}
}

int freeMyField(int *** field, int ranksAmount, int filesAmount) {
	for (int i = 0; i < ranksAmount; i++) {
		for (int j = 0; j < filesAmount; j++) {
			free(field[i][j]);	//Всё ок, в ходе работы inField не может стать null'ом
		}
		free(field[i]);
	}
	free(field);
}

int greetUser() {
	printf("Вас приветствует программа Граф_Конь.\n\n"
		"Программа предназначена для выполнения задания при следующих условиях:\n\n"
		"Имеется поле необычной формы, заданного размера. Каждая клетка пронумерована числами от 1 и далее начиная с верхнего ряда слева направо.\n"
		"Количество горизонтальных рядов в поле, а также количество клеток в рядах поля задаётся пользователем.\n"
		"Фигура - конь. Ходы идентичны таковым у шахматного(Г-образные).\n"
		"Поле представляет собой видоизменённый прямоугольник, каждый следующий ряд которого смещён на * номер ряда * клеток вправо,\n"
		"относительно первого ряда(нулевого), при условии нумерации рядов начиная с 0, или же просто на 1 клетку вправо относительно предыдущего ряда.\n\n"
		"Задание:\n\n"
		"Найти путь фигуры из заданного начального положения в заданное конечное положение(положения задаются номерами строк и позиций в строке)\n"
		"и вывести на экран последовательность чисел, стоящих в клетках этого пути при условии, что нельзя вставать фигурой на две заданные запрещённые клетки.\n\n"
		"Автор: Степаненко Кирилл\nГруппа: ИВТ-13БО\n");
}

int inputInitPos(int * initRank, int * initFile, int ranksAmount, int filesAmount) {
	printf("Обратите внимание, нумерация рядов и клеток начинается с 0!\n");
	printf("Введите номер ряда, в котором находится конь в начале: ");
	if (!scanf("%d", &(*initRank))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if (((*initRank) >= ranksAmount) || ((*initRank) < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		exit(0);
	}
	printf("Введите номер клетки внутри ряда, в которой находится конь в начале: ");
	if (!scanf("%d", &(*initFile))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if (((*initFile) >= filesAmount) || ((*initFile) < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		exit(0);
	}
}

int inputProhPos(int * prohRank, int * prohFile, int ranksAmount, int filesAmount) {
	printf("Введите номер ряда запрещённой клетки: ");
	if (!scanf("%d", &(*prohRank))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if (((*prohRank) >= ranksAmount) || ((*prohRank) < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		exit(0);
	}
	printf("Введите номер запрещённой клетки внутри ряда: ");
	if (!scanf("%d", &(*prohFile))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if (((*prohFile) >= filesAmount) || ((*prohFile) < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		exit(0);
	}
}

int inputRanksAndFiles(int * ranksAmount, int * filesAmount) {
	printf("Введите количество рядов в поле: ");
	if (!scanf("%d", &(*ranksAmount))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if ((*ranksAmount) < 2) {
		printf("Количество рядов в поле не может быть меньше двух, в этом случае задача не имеет смысла.");
		exit(0);
	}
	printf("Введите количество клеток в ряду: ");
	if (!scanf("%d", &(*filesAmount))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if ((*filesAmount) < 2) {
		printf("Количество клеток в ряду не может быть меньше двух, в этом случае задача не имеет смысла.");
		exit(0);
	}
}

int inputTargetPos(int * targetRank, int * targetFile, int ranksAmount, int filesAmount) {
	printf("Введите номер ряда, в котором конь должен находиться в конце: ");
	if (!scanf("%d", &(*targetRank))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if (((*targetRank) >= ranksAmount) || ((*targetRank) < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		exit(0);
	}
	printf("Введите номер клетки внутри ряда, в которой конь должен находиться в конце: ");
	if (!scanf("%d", &(*targetFile))) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		exit(0);
	}
	if (((*targetFile) >= filesAmount) || ((*targetFile) < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		exit(0);
	}
}

int notifyAboutSameCoords(int initRank, int initFile, int targetRank, int targetFile, int prohRank1, int prohFile1, int prohRank2, int prohFile2) {
	if ((prohRank1 == initRank && prohFile1 == initFile) || (prohRank2 == initRank && prohFile2 == initFile)) {
		printf("Координаты одной или обоих запрещённых клеток совпадают с начальной позицией коня.\n"
			"Предполагается отсутствие запрещённых клеток, координаты которых совпадают с начальной позицией.\n");
	}
	if ((prohRank1 == targetRank && prohFile1 == targetFile) || (prohRank2 == targetRank && prohFile2 == targetFile)) {
		printf("Координаты одной или обоих запрещённых клеток совпадают с конечной позицией коня.\n"
			"Предполагается отсутствие запрещённых клеток, координаты которых совпадают с конечной позицией.\n");
	}
	if (prohRank1 == prohRank2 && prohFile1 == prohFile2) {
		printf("Координаты указанных запрещённых точек совпадают. Запрещённая точка будет одна.\n");
	}
}