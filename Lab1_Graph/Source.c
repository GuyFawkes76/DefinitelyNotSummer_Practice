/*
*	Программа Граф_Конь (Graph_Horse)
*
*	Программа предназначена для выполнения задания при следующих условиях:
*
*	Имеется поле необычной формы, заданного размера. Каждая клетка пронумерована числами от 1 и далее начиная с верхнего ряда слева направо.
*	Количество горизонтальных рядов в поле, а также количество клеток в рядах поля задаётся пользователем.
*	Фигура - конь. Ходы идентичны таковым у шахматного (Г-образные).
*	Поле представляет собой видоизменённый прямоугольник, каждый следующий ряд которого смещён на *номер ряда* клеток вправо,
*	относительно первого ряда (нулевого), при условии нумерации рядов начиная с 0, или же просто на 1 клетку вправо относительно предыдущего ряда.
*
*	Задание:
*
*	Найти путь фигуры из заданного начального положения в заданное конечное положение (положения задаются номерами строк и позиций в строке)
*	и вывести на экран последовательность чисел, стоящих в клетках этого пути при условии, что нельзя вставать фигурой на две заданные запрещённые клетки.
*
*	Текущий файл Source.c содержит в себе основную функцию main и включение всех необходимых файлов.
*
*	Автор: Степаненко Кирилл
*	Группа: ИВТ-13БО
*/
#define _CRT_SECURE_NO_WARNINGS
#include <locale.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "mygraphlib.h"

void main() {
	int ranksAmount,		//Количество рядов в поле.
		filesAmount,		//Количество клеток в ряду.
		initRank,			//Номер ряда в начальном положении.
		initFile,			//Номер клетки в начальном положении.
		targetRank,			//Номер ряда в конечном положении.
		targetFile,			//Номер клетки в конечном положении.
		prohRank1,			//Номер ряда первой запрещённой клетки.
		prohFile1,			//Номер первой запрещённой клетки в указанном ряду.
		prohRank2,			//Номер ряда второй запрещённой клетки.
		prohFile2,			//Номер второй запрещённой клетки в указанном ряду.
		*** field = NULL,	//Указатель на поле. В ячейке field[i][j][0] хранится значение ячейки. В field[i][j][1] - пометка о том, посещали ли её, является ли она целевой и т.д.
		i,					//Счётчик.
		j,					//Счётчик.
		fillerCnt = 1;		//Счётчик для заполнения поля числами от 1 и далее.
	struct queue* pQueue = NULL,	//Указатель на начало очереди для горизонтального обхода графа. В дальнейшем - элемент очереди.
		* pQueueLast = NULL,		//Указатель на последний элемент очереди.
		* pTemp;					//Временный указатель на предыдущий элемент очереди для определения, сдвинулась ли очередь вперёд.
	setlocale(LC_ALL, "RUS");
	printf("Вас приветствует программа Граф_Конь.\n\n"
		"Программа предназначена для выполнения задания при следующих условиях:\n\n"
		"Имеется поле необычной формы, заданного размера. Каждая клетка пронумерована числами от 1 и далее начиная с верхнего ряда слева направо.\n"
		"Количество горизонтальных рядов в поле, а также количество клеток в рядах поля задаётся пользователем.\n"
		"Фигура - конь. Ходы идентичны таковым у шахматного(Г-образные).\n"
		"Поле представляет собой видоизменённый прямоугольник, каждый следующий ряд которого смещён на * номер ряда * клеток вправо,\n"
		"относительно первого ряда(нулевого), при условии нумерации рядов начиная с 0, или же просто на 1 клетку вправо относительно предыдущего ряда.\n\n"
		"Задание:\n\n"
		"Найти путь фигуры из заданного начального положения в заданное конечное положение(положения задаются номерами строк и позиций в строке)\n"
		"и вывести на экран последовательность чисел, стоящих в клетках этого пути при условии, что нельзя вставать фигурой на две заданные запрещённые клетки.\n\n"
		"Автор: Степаненко Кирилл\nГруппа: ИВТ-13БО\n");
	//Блок ввода и выделения памяти

	printf("Введите количество рядов в поле: ");
	if (!scanf("%d", &ranksAmount)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if (ranksAmount < 2) {
		printf("Количество рядов в поле не может быть меньше двух, в этом случае задача не имеет смысла.");
		return;
	}
	printf("Введите количество клеток в ряду: ");
	if (!scanf("%d", &filesAmount)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if (filesAmount < 2) {
		printf("Количество клеток в ряду не может быть меньше двух, в этом случае задача не имеет смысла.");
		return;
	}
	//Блок выделения памяти
	if (!(field = malloc(ranksAmount * sizeof(int**)))) {	//Проверяем на NULL при выделении памяти
		printf("Ошибка выделения памяти для массива. Поробуйте закрыть ненужные приложения и повторить попытку.");
		return;
	}
	for (i = 0; i < ranksAmount; i++) {
		field[i] = NULL;
		if (!(field[i] = malloc(filesAmount * sizeof(int*)))) {	//Проверяем на NULL при выделении памяти
			printf("Ошибка выделения памяти для массива. Поробуйте закрыть ненужные приложения и повторить попытку.");
			return;
		}
	}
	for (i = 0; i < ranksAmount; i++) {
		for (j = 0; j < filesAmount; j++) {
			if (!(field[i][j] = malloc(2 * sizeof(int)))) {	//Проверяем на NULL при выделении памяти
				printf("Ошибка выделения памяти для массива. Поробуйте закрыть ненужные приложения и повторить попытку.");
				return;
			}
			field[i][j][0] = fillerCnt++;
			//printf(" %d", field[i][j][0]);
			field[i][j][1] = NOTVISITED;
		}
	}
	//Блок ввода начальных координат
	printf("Обратите внимание, нумерация рядов и клеток начинается с 0!\n");
	printf("Введите номер ряда, в котором находится конь в начале: ");
	if (!scanf("%d", &initRank)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((initRank >= ranksAmount) || (initRank < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	printf("Введите номер клетки внутри ряда, в которой находится конь в начале: ");
	if (!scanf("%d", &initFile)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((initFile >= filesAmount) || (initFile < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	//Блок ввода конечных координат
	printf("Введите номер ряда, в котором конь должен находиться в конце: ");
	if (!scanf("%d", &targetRank)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((targetRank >= ranksAmount) || (targetRank < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	printf("Введите номер клетки внутри ряда, в которой конь должен находиться в конце: ");
	if (!scanf("%d", &targetFile)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((targetFile >= filesAmount) || (targetFile < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	//Блок ввода координат первой запрещённой клетки.
	printf("Введите номер ряда первой запрещённой клетки: ");
	if (!scanf("%d", &prohRank1)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((prohRank1 >= ranksAmount) || (prohRank1 < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	printf("Введите номер первой запрещённой клетки внутри ряда: ");
	if (!scanf("%d", &prohFile1)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((prohFile1 >= filesAmount) || (prohFile1 < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	//Блок ввода координат второй запрещённой клетки.
	printf("Введите номер ряда второй запрещённой клетки: ");
	if (!scanf("%d", &prohRank2)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((prohRank2 >= ranksAmount) || (prohRank2 < 0)) {
		printf("Введённый номер ряда не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}
	printf("Введите номер второй запрещённой клетки внутри ряда: ");
	if (!scanf("%d", &prohFile2)) {
		printf("Неверный формат вводимых данных. Проверьте правильность ввода и попробуйте снова.");
		return;
	}
	if ((prohFile2 >= filesAmount) || (prohFile2 < 0)) {
		printf("Введённый номер клетки не находится в поле. Проверьте правильность ввода и повторите попытку.");
		return;
	}

	//Проверка на совпадение координат запрещённых клеток с начальными и предупреждение об этом пользователя.
	if (((prohRank1 == initRank) && (prohFile1 == initFile)) || ((prohRank2 == initRank) && (prohFile2 == initFile))) {
		printf("Координаты одной или обоих запрещённых клеток совпадают с начальной позицией коня.\n" 
			"Предполагается отсутствие запрещённых клеток, координаты которых совпадают с начальной позицией.\n");
	}
	if (((prohRank1 == targetRank) && (prohFile1 == targetFile)) || ((prohRank2 == targetRank) && (prohFile2 == targetFile))) {
		printf("Координаты одной или обоих запрещённых клеток совпадают с конечной позицией коня.\n"
			"Предполагается отсутствие запрещённых клеток, координаты которых совпадают с конечной позицией.\n");
	}
	if ((prohRank1 == prohRank2) && (prohFile1 == prohFile2)) {
		printf("Координаты указанных запрещённых точек совпадают. Запрещённая точка будет одна.\n");
	}
	//Пометка указанных запрещённых клеток как посещённых.
	field[prohRank1][prohFile1][1] = VISITED;
	field[prohRank2][prohFile2][1] = VISITED;
	field[targetRank][targetFile][1] = TARGET;		//Пометка целевой клетки как целевой
	field[initRank][initFile][1] = VISITED;
	//Выделеие памяти для первого элемента очереди.
	if (!(pQueue = malloc(sizeof(struct queue)))) {
		printf("Ошибка выделения памяти для очереди. Попробуйте закрыть ненужные приложения и повторить попытку.");
		return;
	}
	pQueue->curRank = initRank;
	pQueue->curFile = initFile;
	pQueue->curStep = 0;
	pQueue->pPrev = NULL;
	pQueue->pNext = NULL;
	if (!(pQueue->path = malloc(sizeof(int)))) {
		printf("Ошибка выделения памяти. Попробуйте закрыть ненужные приложения и повторить попытку.");
		return;
	}
	pQueue->path[0] = field[initRank][initFile][0];
	pQueueLast = pQueue;
	//Блок вызова функции, добавляющей в очередь возможные ходы.
	while (1) {
		if (getPosSteps(pQueue, &pQueueLast, field, ranksAmount, filesAmount)) {
			break;
		}
		if (!(pQueue->pNext)) {
			printf("Не удалось найти путь с указанными параметрами.");
			break;
		}
		pQueue = pQueue->pNext;
	}
	//Блок очистки памяти.
	clearQueue(pQueue);
	for (i = 0; i < ranksAmount; i++) {
		for (j = 0; j < filesAmount; j++) {
			free(field[i][j]);
		}
		free(field[i]);
	}
	free(field);
	//printf("Brk"); //
}